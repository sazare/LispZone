LAPの読み方のメモ
PARRYのソースに含まれるLAPソースを読んで、意味を想像した
利用したい人もいないと思うので、これは自分のまとめとしての文書。

LAPの仕様書はここにあったが・・・
http://www.softwarepreservation.org/projects/LISP/lisp2/TM-3417_400_00_LISP2_LAP_Spec.pdf
これはIBM360前提らしい。ニモニックが違う。
アーキテクチャの説明も参考にならないかもしれない。

ParryのLAPはmlispかなにかの出力なので、仕様書にあるすべてのパターンを含んでいるわけでもなさそう。
PDP-10のLAPの仕様はみつからなかった。
PDP-10と書いているけれど、PDP-6からの継承らしいので、正確には違うかもしれない。

1. 構造
関数ごとに次のブロックが対応する

(LAP 関数名 SUBR)
   文1
   文2
   ...
   NIL

コンパイラの出力だからか、コメントはないので、コメントの書き方はわからない。


2. 文の構造

タグ   (命令 数字 対象)

命令は、PDP-10のアセンブラのニモニックをベースにしているもの。
数字と対象1は、命令ごとに異なる。
タグはないものもある。ジャンプの飛び先として使われる。1

3. 定義されている関数
言語の処理対象は、LISPのS式の構造をしていると解釈できそう。
関数に渡したり、CARやCDRをとったり。ATOM関数で判定したり

対象には式もかける。関数呼び出しの形になることがあり、その場合の関数として次のものが使われている。

SPECIAL : mlispのspecial宣言された変数を示すものだと思われる。
　　　　　mlispの変数はnewとspecialがある。newは宣言されると領域が確保される。
　　　　　specialはその宣言より前にnewで宣言された変数を示す。らしい
QUOTE   : 1lispのquoteだと思う。atomの名前として解釈されるのだろう。1
E              : 関数名から関数へのポインタをとってくる関数だと思う。関数でなくてもいいのかどうかは不明。


4. 命令
41. MOVE
MOVE
MOVEI
MOVEM

IはImmediate、MはMemoryへという意味だろう。
一般形は

(move n m)
(move n m p)

このnは、レジスタの番号のような気がする。
moveはレジスタからメモリへのコピーで
movem はメモリからレジスタへのコピー。
moveiは、レジスタへの直値のコピー。
と思われる。
nは0,1,2,3と17というのがあった。
レジスタは4個あるようだ。
17は、ERRSETやINPUTなどのシステムコールぽい関数呼び出しなので何か特別なレジスタなのか、別の意味があるのだろう

特に、次のふたつはアセンブラのニモニックから判明。
HLRZ@  : CAR
HRRZ@  : CDR

HLRZとHRRZはPDP-10(というか6)のアセンブラにあった。
ワードの左または右半分を右半分にコピーし、左半分をゼロで埋めると思われる。
ワードの左がCAR、右がCDRであるはずなので。
また@の意味は不明だが、ATOMの名前からS-式のポインタをとってくるのでないか。

42. CLEAR
メモリをクリアするのだろう
(CLEARM n v)
(CLEARB n v)

Bは何なのか??
クリアしてそのポインタをスタックnに設定するということかな
*もしかすると・・・
(CLEARM 1 (SPECIAL A))
は、Aの値をクリアして、Aのポインタをメモリ1に設定するということかも。

43. CALL
関数の呼び出し

CALL n (E 関数名)
JCALL n (E 関数名)

対象に関数名がかける。関数名の場合は(E 関数名)とする
直接書く例はなかったように思う。

nは関数の引数の数。
引数はcallの前にmoveで設定する。たとえば
(move n a)
aをn番目の引数の位置に設定する。
つまり、関数引数の右側のものが大きな数字になる。

JCALLは39回くらいあった。
10箇所くらい確認したが、いずれも関数末尾での呼び出しであり、戻ってこなくてもよいという意味でJUMP CALLだろう。

Wikipediaによると
PDPのアーキテクチャでは、メモリセグメントとプログラムセグメントが分かれているらしいので、(CALL n ...)を実行したときのnは引数に渡すデータのメモリレジスタの値からのオフセットで、(move n ...)が一番右側の引数のオフセットで一致するのかもしれない。
PDPのアーキテクチャにはスタックもあるようだが、nはスタックのトップからのオフセットか??
そこまで深く知る必要がないので、曖昧のまま。

可変長引数の場合はどうなるか?
呼ぶときは引数の数は決定しているので、CALLには違いはなさそう

44. JUMP
JRST 0 タグ
JSP 6 SPECBIND
JUMPN n タグ
JUMPE n タグ

基本はタグへのジャンプ命令。
LAPコード中のTAGnは、mlispのコンパイラが自動生成したタグと思われる。
nがレジスタ番号だとすると、
jumpnとjumpe
はその値が0か1かの判定と思われる。0のときはeでジャンプし
0でなければnでジャンプする。そして0はNILを示す


IF X
の場合は
JMPEでジャンプ
IF not X
の場合は
JMPNでジャンプ


JRSTは無条件ジャンプと思われる。0 の意味は不明。

JSPも無条件ジャンプのように思うが、NEW変数をもつ関数の先頭でしか呼ばれていないので、何か特別な機能があるようなかんじ。
使われている例は関数定義の先頭で
(JSP 6 SPECBIND)
(0 0 (SPECIAL A))
(MOVEI 1 ...)

special変数の数がいろいろかわってもこの6は変わらない。
(0 0 (SPECIAL A))
は、ローカルにNEW宣言した変数Aだが、ここで領域確保し初期化しているのかなと思う。しかし、実はもうひとつ変数Bを定義しているのに、LAPにはでていないのはなぜだろう。NEW変数が全部書かれている関数もある。
6がレジスタ6を意味し、実際の変数の数はSPECBINDに格納されているのかもしれない。


45. PUSH
(PUSH P 対象)
(PUSH P n)
対象には変数(SPECIAL 名前)がかける。その場合は対象の値をスタックに積むのだろうか。
n(数字)の場合は、レジスタnの値をスタックに積む。
pushをすると、Pの値はインクリメント(あるいはデクリメント)されると思う。

関数呼び出しの結果はスタックに置かれるので、その結果を使った計算を続ける場合などはPUSHを使ってパラメタを乗せておいて計算する。

RAISEでは
HURT  ⇦   (HURT + HJUMP * (20 - HURT));
が
TAG12   (MOVE 2 (SPECIAL HURT))
        (MOVEI 1 (QUOTE 24))
        (PUSH P (SPECIAL HJUMP))
        (PUSH P 2)
        (CALL 2 (E *DIF))
        (MOVE 2 -1 P)
        (CALL 2 (E *TIMES))
        (POP P 2)
        (CALL 2 (E *PLUS))
        (MOVEM 1 (SPECIAL HURT))
と変換されている
24は16進でもとの20は10進だろう。
(move n のnはレジスタ番号かもしれない。)
HURT, 24,をメモリ、HJUMP, とメモリ2の値(HURT)を
スタックに積んで2引数で*DIFを呼ぶ。
その結果がスタックの先頭にあるので、
(MOVE 2 -1 P)で、スタック先頭-1(はHJUMPをPUSHしていた)
からメモリの2にコピーしメモリの1,2を引数として*TIMESを呼ぶ。
スタックPの値(HURTをPUSHしていた)をメモリ2に
コピーし2引数で*PLUSを呼ぶ。
その結果はメモリ1にあるので、それをHURTにコピーする。

ということだと思われる。

(MOVE 2 -1 P)
は、スタックポインタP-1の値を1メモリ2にコピーするという意味。

そのほかの例)
(PUSH P (C 0 0 (QUOTE NIL) 0))
(PUSH P (C 0 0 (QUIOTE 36) 0))

(C 0 0 A B)
の意味は不明。
push以外でも普通に使われている。
何か定数を表すのかなと思うが、確証なし。
AとBが等しい数値か、AにS式がかかれBは0。Bに値がありAは0。
など
A=Bの場合は SUB命令に決まっているようで、
(SUB P (C 0 0 n n))
となる
スタックポインタを変更するようなかんじ。
POPは値を取ってくるか、SUBは値を捨てるのかも。

そうでない場合は、Aへのポインタかもしれない。わからない

savej.lapには
(C SAVE# 0)
(C AC1# 0 1)
などの例がmoveのメモリ側に書かれている例がある。


56. POP
(POP P n)
(POPJ P)

POPは、スタック(P)のトップをレジスタnにコピーしてPを-1する。
と思う。

POPJは関数定義の最後の行にしかでてこないようだ
JCALLと対応しているのかもしれない。
値のコピーをしないのだろう。

46. CAI
FRONT.LAPのL439
 435 (LAP GET_CHUCK SUBR)
 436         (PUSH P 1)
 437         (PUSH P 2)
 438         (PUSH P (C 0 0 (QUOTE NIL) 0))
 439         (CAIE 2 (QUOTE SYNONM))
 440         (JRST 0 TAG5)




