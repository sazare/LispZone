20181016(Thu)
1. All.docによると、mlispのコードはlisp1.6に変換されるらしい
2. ERR(), SETERR()はLISP1.6で定義されていた
3. READDATA(はREADINC()の値が'COMMENTでない場合に、処理をしている。
INFには、左端にS式があり、~から右側がコメントになっているようにみえる。
ほかのデータでも、~がコメントになっているものがあった。
INFを読み込むのはREADINF()で、
READDATA()は、READINF()から呼ばれる。
SELECTINPUT()のあとREADDATA()を呼んでいるが、selectinput()が関係しているとは思えない。

READINC()の中では
 INC(INCHAN,NIL)
 I:=READ()
 INC(NIL,NIL)
 RETURN I
しかゃっていない。READが'COMMENTを返すのだろうか。
lisp1.6にもmlispでもREAD()はそんなことはしていない。
たんにS式を返すだけだ。

わからない。


20181014()
- READINFのやっていることがわからなくなってきた
INFにはTH2で、第三要素にformのある行があるが、readinfではそこは単にそのformに対してputpropしている。
lisp1.5ではlistに対するputpropができたのだろうか

- ファイルにランダムアクセスするコードがあったが、まったく読んでいない

20181020 
 @について... RDATAには@のついた式がいくつかある
    @DEFPROPは、FUNCTIONかもしれない。

    (SETQ SETLIST (GET @SETLIST @SETS))
　　　これは変数についているのでQUOTEにみえる。
    (SETQ WTS @(17 15 12 10 9 7 6 5 4 3 1))
　　　これもまたquoteにみえる。あるいはlistかもしれない。

~    %   RESPECTIVE WEIGHTS OF THE GIVEN FLARE CONCEPTS   %

    (SETQ WTS @(17 15 12 10 9 7 6 5 4 3 1))

~    %WEIGHTS ARE ASSIGNED TO CONCEPTS RATHER THAN TO INDIVIDUAL WORDS%

    (SETQ FLARELIST (GET @FLARELIST @SETS))
    (MAPCAR (FUNCTION (LAMBDA (WT) (PROG2 (PUTPROP (CAR FLARELIST) WT @WT)
                                          (SETQ FLARELIST (CDR FLARELIST))
                                   ))) WTS)
     この1行目は上と同じ。2行目の@WTもまたquoteに思える。
     (putprop xxx 1 '1)などということはできないと思う・・・
     こめんとによると、FLARELISTにはCONCEPTがならんでいて、WTは同じ数のwightらしい。

　　RDATAはOPAR3でのみ参照していて
    EXPR  OPARINITIALIZE ();
         BEGIN
                EVAL '(INC (INPUT (PAR BLF) RDATA) NIL);
                WHILE NOT ATOM X  ⇦   ERRSET(READ(),T) DO EVAL CAR X;
                INC(NIL,T);
　　     ....
　　RDATAはデータとして読み込んで、EVALして使っているのだろうか。INC, INPUT、はわからない。lisp1.6かな
    (PAR BLF)は変数なのか???
    (PAR BLF)はa(DSKIN ..) の引数に使われている。が、DOR*の中は制御文字多発
    バイナリファイルからのデータなのだろうか。
    謎


20181022
RDATB やRDATAで、defpropがでてきて
(defprop A B C)
と書いていた。
すべてのAについて(defvar A)が必要になるので、macroでできないかやってみたが
(defmacro defprop (a b c)
(progn
 (defvar ,a)
 (setf (get ',a ',c) ,b)
)
)

だと、defvarしたaのスコープがprognの中になってしまい思ったようにならない。
defvarなしでメッセージでるけどいいのか??

別途, defvarを作ったらどうかと思ったら、rdataでは mapでdefpropをまわしていて,
そこから アトムをすべて集めるのがめんどう・・・

しかし、いずれにせよglobalなatomをどうにかする必要はでてくる。
データ中のアトムにputpropしているから・・・
動的束縛は楽だ・・・


20181024水
rdata.lispのインデントがおかしいので、手で修正した
また、グローバル変数 flarelistとpointersを*～*にしてdefvarした
これらの変数はatomとしてもでてきているので、この対処が間違っている可能性もありそう。
rdata1.lispとして修正版を作った

関数    -> 処理したatomのたまる変数
defprop ->  *AOPUTPLIST*
putprop -> *AODEFPLIST*
readbel -> *INTLIST*

readinfはまだ対応していない。するとしたらλ名をとりこむのかな

(map (lambda (x) (print (symbol-plist x))))
みたいなことをすれば
プロパティの全貌がわかる

PDATBにでてくるatom->prop名->atomのグラフを作成した
Rのigraphを用いていてRスクリプトはparryplot.R
pdatb.graphは元のpdatbから()を取り除いた
pdatab.epsが作成したグラフ

これをみると、ほとんど重複がない。UNITとかINDの意味がよくわからない

20181025木
- pmem4.lispに日本語のコメントをいれていたら、Windowsで意味不明のエラーになってしまった。日本語をやめる

- files.csvの内容を絵にかいてみた。すこしは全体像がわかるかも。
- utils.lispは、cparryのatomのpropertyの関係を見えるようにするための道具。
defpropとputpropで定義したpropertyをigraphでなんとかみたい。
一方でinfはどうしようか。思案中

20181027土
- test.lispのexpectとvalueを別の行にした。みやすさ
- utils.lispは、propertylistによるグラフ構造をigraphで表示するための中間データ作成
- testxxx.lispをtest-xxx.lispに変更した
  - git mvすべきだったが、mvしてしまった
* 変数名に*-*をつける必要はないようなきがする。今回つけた*はとくに・・・
  - commonlispのルールみたいになっていたのでglobal変数に*-*をつけてはみたものの
　　たとえばSETLIST, FLARELIST, SENSITIVELISTは、
    property listから取り出したデータをatomの値にしていると考えるべきだ。
　　だからこれらの変数には*をつけないことにしよう。

* 元のソースをベースに、commonlisp用に変更していくという方法
　- 不要な関数をだみーにし、必要なものだけ変更していく・・・それでもうまくいくだろうか
    悩み中

* RDATAにある~はコメントではなくnotのようだ。
　しかもコメントの~もある。区別している文脈がわからない。やりなおしかも。くたびれた

  そもそも  
  RDATA<-OPAR3/oparinitialize <- PMEM4/INITB <- PMEM4/INITFB <- DOR,DORS
  となっていてDORはプログラムではない何かスクリプトの実行ログのようにみえる。
　RDATAを参照する関数は、今のファイルにはないが、古いParryからもってきたコードだと
　いうことなので、手で初期化するときに使っているというような話かもしれない。

  RDATAの困った点
  - ~はコメントなのか、notなのか?
　- @はquoteなのか(これがあるから^Hを@@にするのはよくないかも)
  - DELNSETの定義をみると、わけがわからない。
  - STLの定義をmapcarしているのをみると, (cons @DEFPROP X)してevalしている。
　- PDATB から(defprop a b c)のときproperty名はcになる。

　さて。やはり~はコメントと考えるべきだと思う。


 

