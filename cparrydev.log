20181016(Thu)
1. All.docによると、mlispのコードはlisp1.6に変換されるらしい
2. ERR(), SETERR()はLISP1.6で定義されていた
3. READDATA(はREADINC()の値が'COMMENTでない場合に、処理をしている。
INFには、左端にS式があり、~から右側がコメントになっているようにみえる。
ほかのデータでも、~がコメントになっているものがあった。
INFを読み込むのはREADINF()で、
READDATA()は、READINF()から呼ばれる。
SELECTINPUT()のあとREADDATA()を呼んでいるが、selectinput()が関係しているとは思えない。

READINC()の中では
 INC(INCHAN,NIL)
 I:=READ()
 INC(NIL,NIL)
 RETURN I
しかゃっていない。READが'COMMENTを返すのだろうか。
lisp1.6にもmlispでもREAD()はそんなことはしていない。
たんにS式を返すだけだ。

わからない。


20181014()
- READINFのやっていることがわからなくなってきた
INFにはTH2で、第三要素にformのある行があるが、readinfではそこは単にそのformに対してputpropしている。
lisp1.5ではlistに対するputpropができたのだろうか

- ファイルにランダムアクセスするコードがあったが、まったく読んでいない

20181020 
 @について... RDATAには@のついた式がいくつかある
    @DEFPROPは、FUNCTIONかもしれない。

    (SETQ SETLIST (GET @SETLIST @SETS))
　　　これは変数についているのでQUOTEにみえる。
    (SETQ WTS @(17 15 12 10 9 7 6 5 4 3 1))
　　　これもまたquoteにみえる。あるいはlistかもしれない。

~    %   RESPECTIVE WEIGHTS OF THE GIVEN FLARE CONCEPTS   %

    (SETQ WTS @(17 15 12 10 9 7 6 5 4 3 1))

~    %WEIGHTS ARE ASSIGNED TO CONCEPTS RATHER THAN TO INDIVIDUAL WORDS%

    (SETQ FLARELIST (GET @FLARELIST @SETS))
    (MAPCAR (FUNCTION (LAMBDA (WT) (PROG2 (PUTPROP (CAR FLARELIST) WT @WT)
                                          (SETQ FLARELIST (CDR FLARELIST))
                                   ))) WTS)
     この1行目は上と同じ。2行目の@WTもまたquoteに思える。
     (putprop xxx 1 '1)などということはできないと思う・・・
     こめんとによると、FLARELISTにはCONCEPTがならんでいて、WTは同じ数のwightらしい。

　　RDATAはOPAR3でのみ参照していて
    EXPR  OPARINITIALIZE ();
         BEGIN
                EVAL '(INC (INPUT (PAR BLF) RDATA) NIL);
                WHILE NOT ATOM X  ⇦   ERRSET(READ(),T) DO EVAL CAR X;
                INC(NIL,T);
　　     ....
　　RDATAはデータとして読み込んで、EVALして使っているのだろうか。INC, INPUT、はわからない。lisp1.6かな
    (PAR BLF)は変数なのか???
    (PAR BLF)はa(DSKIN ..) の引数に使われている。が、DOR*の中は制御文字多発
    バイナリファイルからのデータなのだろうか。
    謎


20181022
RDATB やRDATAで、defpropがでてきて
(defprop A B C)
と書いていた。
すべてのAについて(defvar A)が必要になるので、macroでできないかやってみたが
(defmacro defprop (a b c)
(progn
 (defvar ,a)
 (setf (get ',a ',c) ,b)
)
)

だと、defvarしたaのスコープがprognの中になってしまい思ったようにならない。
defvarなしでメッセージでるけどいいのか??

別途, defvarを作ったらどうかと思ったら、rdataでは mapでdefpropをまわしていて,
そこから アトムをすべて集めるのがめんどう・・・

しかし、いずれにせよglobalなatomをどうにかする必要はでてくる。
データ中のアトムにputpropしているから・・・
動的束縛は楽だ・・・


20181024水
rdata.lispのインデントがおかしいので、手で修正した
また、グローバル変数 flarelistとpointersを*～*にしてdefvarした
これらの変数はatomとしてもでてきているので、この対処が間違っている可能性もありそう。
rdata1.lispとして修正版を作った

関数    -> 処理したatomのたまる変数
defprop ->  *AOPUTPLIST*
putprop -> *AODEFPLIST*
readbel -> *INTLIST*

readinfはまだ対応していない。するとしたらλ名をとりこむのかな

(map (lambda (x) (print (symbol-plist x))))
みたいなことをすれば
プロパティの全貌がわかる

PDATBにでてくるatom->prop名->atomのグラフを作成した
Rのigraphを用いていてRスクリプトはparryplot.R
pdatb.graphは元のpdatbから()を取り除いた
pdatab.epsが作成したグラフ

これをみると、ほとんど重複がない。UNITとかINDの意味がよくわからない

20181025木
- pmem4.lispに日本語のコメントをいれていたら、Windowsで意味不明のエラーになってしまった。日本語をやめる

- files.csvの内容を絵にかいてみた。すこしは全体像がわかるかも。
- utils.lispは、cparryのatomのpropertyの関係を見えるようにするための道具。
defpropとputpropで定義したpropertyをigraphでなんとかみたい。
一方でinfはどうしようか。思案中

20181027土
- test.lispのexpectとvalueを別の行にした。みやすさ
- utils.lispは、propertylistによるグラフ構造をigraphで表示するための中間データ作成
- testxxx.lispをtest-xxx.lispに変更した
  - git mvすべきだったが、mvしてしまった
* 変数名に*-*をつける必要はないようなきがする。今回つけた*はとくに・・・
  - commonlispのルールみたいになっていたのでglobal変数に*-*をつけてはみたものの
　　たとえばSETLIST, FLARELIST, SENSITIVELISTは、
    property listから取り出したデータをatomの値にしていると考えるべきだ。
　　だからこれらの変数には*をつけないことにしよう。

* 元のソースをベースに、commonlisp用に変更していくという方法
　- 不要な関数をだみーにし、必要なものだけ変更していく・・・それでもうまくいくだろうか
    悩み中

* RDATAにある~はコメントではなくnotのようだ。
　しかもコメントの~もある。区別している文脈がわからない。やりなおしかも。くたびれた

  そもそも  
  RDATA<-OPAR3/oparinitialize <- PMEM4/INITB <- PMEM4/INITFB <- DOR,DORS
  となっていてDORはプログラムではない何かスクリプトの実行ログのようにみえる。
　RDATAを参照する関数は、今のファイルにはないが、古いParryからもってきたコードだと
　いうことなので、手で初期化するときに使っているというような話かもしれない。

  RDATAの困った点
  - ~はコメントなのか、notなのか?
　- @はquoteなのか(これがあるから^Hを@@にするのはよくないかも)
  - DELNSETの定義をみると、わけがわからない。
  - STLの定義をmapcarしているのをみると, (cons @DEFPROP X)してevalしている。
　- PDATB から(defprop a b c)のときproperty名はcになる。

　さて。やはり~はコメントと考えるべきだと思う。

20181031水
1. RDATAを解読してみた。@がよくわからないが、quoteだと仮定した。
  - マフィアに関する妄想がどのように生まれるかが定義されていた。
　- キーとなる語を、FLARELIST, SETLIST, SENSITIVEにわけて、
　　各LISTのproperty SETS にはconceptと呼ばれる言葉のlistが定義され
　　各conceptの各言葉のproperty WORDS にはそのconceptに属する単語が登録されている
　　また、conceptのproperty WTにはその重みが登録されている。
  - L65あたりからは、concept 〜SETの間で、最終的にMAFIASETにいたる遷移が定義されている。
　　property NEXTは遷移の次の状態を示す。
　- とにかく重要なデータなので、RDATAを参照していないとは考えにくい。
    これも移す。

2. property listで複雑な構造を作っているので、全体を見るためにt.lisp/showtree を作った。
   (showtree <atom> '(words sets set) ())
　というように使う。atomには'FLARELIST, 'SENSITIVELIST, 'SETLISTを想定。
　words, sets, setは階層になってるproperty list
  第三引数は作業用なので必ず()にする。

  これをつかって、マフィア妄想の状態遷移をダンプするときはこうなる。
  遷移図の矢印はproperty nextになっているので。
  (showlist (get 'flarelist 'sets) '(next) Nil)

  storyを全部表示するのはこう。無駄にlambda名が表示されたので、lambda名は表示しないようにするためpmem.lispを参照してしまった。
　(showlist (mapcar (lambda (x) (car x)) stl) '(story) () )


3. SETLISTの値は、SETLIST.SETSと同じになっているが、FLARELISTとSENSITIVELISTはNIL。
　重みをつけるときに消している。いいのだろうか。もともとそうだ。

4. INPUTQUE はassoc listになっている。



